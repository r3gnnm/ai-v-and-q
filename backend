from fastapi import FastAPI, File, UploadFile, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import uvicorn
from pathlib import Path
import uuid
import json

app = FastAPI(
    title="Video Quiz System API",
    description="AI-powered video segmentation and quiz generation",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Models
class VideoMetadata(BaseModel):
    id: str
    filename: str
    duration: float
    status: str  # processing, ready, error
    segments_count: int = 0

class Segment(BaseModel):
    id: str
    video_id: str
    start_time: str
    end_time: str
    topic_title: str
    short_summary: str
    keywords: List[str]
    quiz_id: Optional[str] = None

class Question(BaseModel):
    id: str
    type: str  # multiple_choice, true_false, short_answer
    question: str
    options: Optional[List[str]] = None  # для multiple_choice
    correct_answer: str

class Quiz(BaseModel):
    id: str
    segment_id: str
    questions: List[Question]

class AnswerSubmission(BaseModel):
    question_id: str
    user_answer: str

class QuizResult(BaseModel):
    correct: bool
    correct_answer: Optional[str] = None
    message: str

class UserProgress(BaseModel):
    user_id: str
    video_id: str
    completed_segments: List[int]
    current_segment: int
    locked: bool

# Storage
videos_db = {}
segments_db = {}
quizzes_db = {}
progress_db = {}

UPLOAD_DIR = Path("uploads")
UPLOAD_DIR.mkdir(exist_ok=True)

# Endpoints

@app.get("/")
def root():
    return {
        "message": "Video Quiz System API",
        "docs": "/docs",
        "version": "1.0.0"
    }

@app.post("/video/upload", response_model=VideoMetadata)
async def upload_video(file: UploadFile = File(...)):
    """
    Загрузка видео и запуск обработки
    """
    # Валидация формата
    if not file.filename.endswith(('.mp4', '.mov', '.avi')):
        raise HTTPException(400, "Unsupported format. Use .mp4, .mov, or .avi")
    
    # Сохранение файла
    video_id = str(uuid.uuid4())
    file_path = UPLOAD_DIR / f"{video_id}_{file.filename}"
    
    with open(file_path, "wb") as f:
        content = await file.read()
        f.write(content)
    
    # Создание записи
    video_meta = VideoMetadata(
        id=video_id,
        filename=file.filename,
        duration=0.0,  # будет обновлено после обработки
        status="processing"
    )
    
    videos_db[video_id] = video_meta.dict()
    
    # TODO: Запустить фоновую обработку (Celery task)
    # process_video_task.delay(video_id, str(file_path))
    
    return video_meta

@app.get("/video/{video_id}", response_model=VideoMetadata)
def get_video_info(video_id: str):
    """
    Получить информацию о видео
    """
    if video_id not in videos_db:
        raise HTTPException(404, "Video not found")
    
    return videos_db[video_id]

@app.get("/video/{video_id}/segments", response_model=List[Segment])
def get_video_segments(video_id: str):
    """
    Получить все сегменты видео
    """
    if video_id not in videos_db:
        raise HTTPException(404, "Video not found")
    
    # Фильтруем сегменты по video_id
    video_segments = [
        Segment(**seg) for seg in segments_db.values() 
        if seg['video_id'] == video_id
    ]
    
    return sorted(video_segments, key=lambda x: x.start_time)

@app.get("/segment/{segment_id}/quiz", response_model=Quiz)
def get_segment_quiz(segment_id: str):
    """
    Получить тест для сегмента
    """
    if segment_id not in segments_db:
        raise HTTPException(404, "Segment not found")
    
    segment = segments_db[segment_id]
    quiz_id = segment.get('quiz_id')
    
    if not quiz_id or quiz_id not in quizzes_db:
        raise HTTPException(404, "Quiz not found for this segment")
    
    return quizzes_db[quiz_id]

@app.post("/segment/{segment_id}/answer", response_model=QuizResult)
def submit_answer(segment_id: str, answer: AnswerSubmission):
    """
    Проверить ответ на вопрос
    """
    if segment_id not in segments_db:
        raise HTTPException(404, "Segment not found")
    
    segment = segments_db[segment_id]
    quiz_id = segment.get('quiz_id')
    
    if not quiz_id or quiz_id not in quizzes_db:
        raise HTTPException(404, "Quiz not found")
    
    quiz = quizzes_db[quiz_id]
    
    # Найти вопрос
    question = next(
        (q for q in quiz['questions'] if q['id'] == answer.question_id),
        None
    )
    
    if not question:
        raise HTTPException(404, "Question not found")
    
    # Проверка ответа
    correct = answer.user_answer.strip().lower() == question['correct_answer'].strip().lower()
    
    return QuizResult(
        correct=correct,
        correct_answer=question['correct_answer'] if not correct else None,
        message="Correct! You may continue." if correct else "Incorrect. Please rewatch the segment."
    )

@app.get("/video/{video_id}/progress/{user_id}", response_model=UserProgress)
def get_user_progress(video_id: str, user_id: str):
    """
    Получить прогресс пользователя
    """
    key = f"{user_id}:{video_id}"
    
    if key not in progress_db:
        # Инициализация прогресса
        progress = UserProgress(
            user_id=user_id,
            video_id=video_id,
            completed_segments=[],
            current_segment=0,
            locked=False
        )
        progress_db[key] = progress.dict()
    
    return progress_db[key]

@app.post("/video/{video_id}/progress/{user_id}/complete")
def complete_segment(video_id: str, user_id: str, segment_index: int):
    """
    Отметить сегмент как пройденный
    """
    key = f"{user_id}:{video_id}"
    
    if key not in progress_db:
        raise HTTPException(404, "Progress not found")
    
    progress = progress_db[key]
    
    if segment_index not in progress['completed_segments']:
        progress['completed_segments'].append(segment_index)
        progress['current_segment'] = segment_index + 1
    
    return {"message": "Segment completed", "progress": progress}

# Debug

@app.post("/debug/create_test_data")
def create_test_data():
    """
    Создать тестовые данные для разработки
    """
    video_id = "test-video-001"
    
    # Видео
    videos_db[video_id] = {
        "id": video_id,
        "filename": "test_lecture.mp4",
        "duration": 600.0,
        "status": "ready",
        "segments_count": 3
    }
    
    # Сегменты
    test_segments = [
        {
            "id": "seg-001",
            "video_id": video_id,
            "start_time": "00:00:00",
            "end_time": "00:03:20",
            "topic_title": "Introduction to Python",
            "short_summary": "Basic overview of Python programming language",
            "keywords": ["python", "programming", "basics"],
            "quiz_id": "quiz-001"
        },
        {
            "id": "seg-002",
            "video_id": video_id,
            "start_time": "00:03:20",
            "end_time": "00:07:15",
            "topic_title": "Variables and Data Types",
            "short_summary": "Understanding variables, strings, integers, and floats",
            "keywords": ["variables", "data types", "strings"],
            "quiz_id": "quiz-002"
        }
    ]
    
    for seg in test_segments:
        segments_db[seg['id']] = seg
    
    # Квизы
    quizzes_db["quiz-001"] = {
        "id": "quiz-001",
        "segment_id": "seg-001",
        "questions": [
            {
                "id": "q1",
                "type": "multiple_choice",
                "question": "What is Python?",
                "options": ["A snake", "A programming language", "A type of coffee", "A framework"],
                "correct_answer": "A programming language"
            },
            {
                "id": "q2",
                "type": "true_false",
                "question": "Python is a compiled language",
                "options": ["True", "False"],
                "correct_answer": "False"
            }
        ]
    }
    
    quizzes_db["quiz-002"] = {
        "id": "quiz-002",
        "segment_id": "seg-002",
        "questions": [
            {
                "id": "q3",
                "type": "short_answer",
                "question": "What keyword is used to create a variable in Python?",
                "correct_answer": "no keyword needed"
            }
        ]
    }
    
    return {"message": "Test data created", "video_id": video_id}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
